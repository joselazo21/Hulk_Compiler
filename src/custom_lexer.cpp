#include "custom_lexer.hpp"
#include <iostream>
#include <cctype>
#include <cstring>
#include <cstdlib>

// Global variables for Bison compatibility
int yylineno = 1;
int yycolumn = 1;
char* yytext = nullptr;
double yylval_dval = 0.0;
char* yylval_sval = nullptr;

// Global lexer instance
CustomLexer* globalLexer = nullptr;

// Bison token values (must match the values in SintacticoBison.tab.hpp)
// These values will be generated by Bison, but we need placeholders
#define NUMBER_TOKEN 258
#define ID_TOKEN 259
#define STRING_TOKEN 260
#define LET_TOKEN 261
#define IN_TOKEN 262
#define PRINT_TOKEN 263
#define FUNCTION_TOKEN 264
#define IF_TOKEN 265
#define ELSE_TOKEN 266
#define ELIF_TOKEN 267
#define WHILE_TOKEN 268
#define FOR_TOKEN 269
#define CONCAT_TOKEN 270
#define CONCAT_WS_TOKEN 271
#define ARROW_TOKEN 272
#define EQ_TOKEN 273
#define NEQ_TOKEN 274
#define LE_TOKEN 275
#define GE_TOKEN 276
#define AND_TOKEN 277
#define OR_TOKEN 278
#define ASSIGN_TOKEN 279
#define TYPE_TOKEN 280
#define INHERITS_TOKEN 281
#define NEW_TOKEN 282
#define SELF_TOKEN 283
#define BASE_TOKEN 284
#define IS_TOKEN 285

CustomToken::CustomToken(CustomTokenType t, const std::string& l, int ln, int col, double val)
    : type(t), lexeme(l), line(ln), column(col), numericValue(val) {}

std::string CustomToken::toString() const {
    std::string typeStr;
    switch (type) {
        case CustomTokenType::LET: typeStr = "LET"; break;
        case CustomTokenType::PRINT: typeStr = "PRINT"; break;
        case CustomTokenType::FUNCTION: typeStr = "FUNCTION"; break;
        case CustomTokenType::IF: typeStr = "IF"; break;
        case CustomTokenType::ELSE: typeStr = "ELSE"; break;
        case CustomTokenType::ELIF: typeStr = "ELIF"; break;
        case CustomTokenType::WHILE: typeStr = "WHILE"; break;
        case CustomTokenType::FOR: typeStr = "FOR"; break;
        case CustomTokenType::IN: typeStr = "IN"; break;
        case CustomTokenType::TYPE: typeStr = "TYPE"; break;
        case CustomTokenType::NEW: typeStr = "NEW"; break;
        case CustomTokenType::INHERITS: typeStr = "INHERITS"; break;
        case CustomTokenType::SELF: typeStr = "SELF"; break;
        case CustomTokenType::BASE: typeStr = "BASE"; break;
        case CustomTokenType::IS: typeStr = "IS"; break;
        case CustomTokenType::ASSIGN: typeStr = "ASSIGN"; break;
        case CustomTokenType::ASSIGN_OP: typeStr = "ASSIGN_OP"; break;
        case CustomTokenType::EQ: typeStr = "EQ"; break;
        case CustomTokenType::NEQ: typeStr = "NEQ"; break;
        case CustomTokenType::LE: typeStr = "LE"; break;
        case CustomTokenType::GE: typeStr = "GE"; break;
        case CustomTokenType::AND: typeStr = "AND"; break;
        case CustomTokenType::OR: typeStr = "OR"; break;
        case CustomTokenType::ARROW: typeStr = "ARROW"; break;
        case CustomTokenType::CONCAT: typeStr = "CONCAT"; break;
        case CustomTokenType::CONCAT_WS: typeStr = "CONCAT_WS"; break;
        case CustomTokenType::MOD: typeStr = "MOD"; break;
        case CustomTokenType::PLUS: typeStr = "PLUS"; break;
        case CustomTokenType::MINUS: typeStr = "MINUS"; break;
        case CustomTokenType::MULT: typeStr = "MULT"; break;
        case CustomTokenType::DIV: typeStr = "DIV"; break;
        case CustomTokenType::POW: typeStr = "POW"; break;
        case CustomTokenType::LT: typeStr = "LT"; break;
        case CustomTokenType::GT: typeStr = "GT"; break;
        case CustomTokenType::COLON: typeStr = "COLON"; break;
        case CustomTokenType::DOT: typeStr = "DOT"; break;
        case CustomTokenType::LPAREN: typeStr = "LPAREN"; break;
        case CustomTokenType::RPAREN: typeStr = "RPAREN"; break;
        case CustomTokenType::LBRACE: typeStr = "LBRACE"; break;
        case CustomTokenType::RBRACE: typeStr = "RBRACE"; break;
        case CustomTokenType::LBRACKET: typeStr = "LBRACKET"; break;
        case CustomTokenType::RBRACKET: typeStr = "RBRACKET"; break;
        case CustomTokenType::COMMA: typeStr = "COMMA"; break;
        case CustomTokenType::SEMICOLON: typeStr = "SEMICOLON"; break;
        case CustomTokenType::PIPE: typeStr = "PIPE"; break;
        case CustomTokenType::NUMBER: typeStr = "NUMBER"; break;
        case CustomTokenType::ID: typeStr = "ID"; break;
        case CustomTokenType::STRING: typeStr = "STRING"; break;
        case CustomTokenType::END_OF_FILE: typeStr = "EOF"; break;
        case CustomTokenType::ERROR: typeStr = "ERROR"; break;
        default: typeStr = "UNKNOWN"; break;
    }
    
    if (type == CustomTokenType::NUMBER) {
        return "<" + typeStr + ":" + lexeme + ">";
    } else if (type == CustomTokenType::ID || type == CustomTokenType::STRING) {
        return "<" + typeStr + ":" + lexeme + ">";
    } else {
        return "<" + typeStr + ">";
    }
}

int CustomToken::toBisonToken() const {
    switch (type) {
        case CustomTokenType::NUMBER: return NUMBER_TOKEN;
        case CustomTokenType::ID: return ID_TOKEN;
        case CustomTokenType::STRING: return STRING_TOKEN;
        case CustomTokenType::LET: return LET_TOKEN;
        case CustomTokenType::IN: return IN_TOKEN;
        case CustomTokenType::PRINT: return PRINT_TOKEN;
        case CustomTokenType::FUNCTION: return FUNCTION_TOKEN;
        case CustomTokenType::IF: return IF_TOKEN;
        case CustomTokenType::ELSE: return ELSE_TOKEN;
        case CustomTokenType::ELIF: return ELIF_TOKEN;
        case CustomTokenType::WHILE: return WHILE_TOKEN;
        case CustomTokenType::FOR: return FOR_TOKEN;
        case CustomTokenType::CONCAT: return CONCAT_TOKEN;
        case CustomTokenType::CONCAT_WS: return CONCAT_WS_TOKEN;
        case CustomTokenType::ARROW: return ARROW_TOKEN;
        case CustomTokenType::EQ: return EQ_TOKEN;
        case CustomTokenType::NEQ: return NEQ_TOKEN;
        case CustomTokenType::LE: return LE_TOKEN;
        case CustomTokenType::GE: return GE_TOKEN;
        case CustomTokenType::AND: return AND_TOKEN;
        case CustomTokenType::OR: return OR_TOKEN;
        case CustomTokenType::ASSIGN: return ASSIGN_TOKEN;
        case CustomTokenType::ASSIGN_OP: return ASSIGN_TOKEN + 1; // Use next available token number
        case CustomTokenType::TYPE: return TYPE_TOKEN;
        case CustomTokenType::INHERITS: return INHERITS_TOKEN;
        case CustomTokenType::NEW: return NEW_TOKEN;
        case CustomTokenType::SELF: return SELF_TOKEN;
        case CustomTokenType::BASE: return BASE_TOKEN;
        case CustomTokenType::IS: return IS_TOKEN;
        
        // Single character tokens return their ASCII value
        case CustomTokenType::PLUS: return '+';
        case CustomTokenType::MINUS: return '-';
        case CustomTokenType::MULT: return '*';
        case CustomTokenType::DIV: return '/';
        case CustomTokenType::POW: return '^';
        case CustomTokenType::MOD: return '%';
        case CustomTokenType::LT: return '<';
        case CustomTokenType::GT: return '>';
        case CustomTokenType::COLON: return ':';
        case CustomTokenType::DOT: return '.';
        case CustomTokenType::LPAREN: return '(';
        case CustomTokenType::RPAREN: return ')';
        case CustomTokenType::LBRACE: return '{';
        case CustomTokenType::RBRACE: return '}';
        case CustomTokenType::LBRACKET: return '[';
        case CustomTokenType::RBRACKET: return ']';
        case CustomTokenType::COMMA: return ',';
        case CustomTokenType::SEMICOLON: return ';';
        case CustomTokenType::PIPE: return '|';
        
        case CustomTokenType::END_OF_FILE: return 0;
        case CustomTokenType::ERROR: return -1;
        default: return -1;
    }
}

CustomLexer::CustomLexer(const std::string& source) 
    : input(source), position(0), line(1), column(1) {
    initializeSymbolTables();
    
    if (!input.empty()) {
        currentChar = input[0];
    } else {
        currentChar = '\0';
    }
}

void CustomLexer::initializeSymbolTables() {
    initializeKeywords();
    initializeOperators();
    initializeDelimiters();
}

void CustomLexer::initializeKeywords() {
    keywords["let"] = CustomTokenType::LET;
    keywords["print"] = CustomTokenType::PRINT;
    keywords["function"] = CustomTokenType::FUNCTION;
    keywords["if"] = CustomTokenType::IF;
    keywords["else"] = CustomTokenType::ELSE;
    keywords["elif"] = CustomTokenType::ELIF;
    keywords["while"] = CustomTokenType::WHILE;
    keywords["for"] = CustomTokenType::FOR;
    keywords["in"] = CustomTokenType::IN;
    keywords["type"] = CustomTokenType::TYPE;
    keywords["new"] = CustomTokenType::NEW;
    keywords["inherits"] = CustomTokenType::INHERITS;
    keywords["self"] = CustomTokenType::SELF;
    keywords["base"] = CustomTokenType::BASE;
    keywords["is"] = CustomTokenType::IS;
}

void CustomLexer::initializeOperators() {
    // Multi-character operators (must be checked first)
    operators[":="] = CustomTokenType::ASSIGN_OP;
    operators["=="] = CustomTokenType::EQ;
    operators["!="] = CustomTokenType::NEQ;
    operators["<="] = CustomTokenType::LE;
    operators[">="] = CustomTokenType::GE;
    operators["=>"] = CustomTokenType::ARROW;
    operators["&&"] = CustomTokenType::AND;
    operators["||"] = CustomTokenType::OR;
    operators["@@"] = CustomTokenType::CONCAT_WS;
    
    // Single-character operators
    operators["="] = CustomTokenType::ASSIGN;
    operators["<"] = CustomTokenType::LT;
    operators[">"] = CustomTokenType::GT;
    operators["+"] = CustomTokenType::PLUS;
    operators["-"] = CustomTokenType::MINUS;
    operators["*"] = CustomTokenType::MULT;
    operators["/"] = CustomTokenType::DIV;
    operators["^"] = CustomTokenType::POW;
    operators["%"] = CustomTokenType::MOD;
    operators["@"] = CustomTokenType::CONCAT;
    operators["."] = CustomTokenType::DOT;
    operators[":"] = CustomTokenType::COLON;
    
    // Single character operator set for quick lookup
    singleCharOperators = {'=', '<', '>', '+', '-', '*', '/', '^', '%', '@', '.', ':', '&', '|', '!'};
}

void CustomLexer::initializeDelimiters() {
    delimiters = {'(', ')', '{', '}', '[', ']', ',', ';', '|'};
}

void CustomLexer::advance() {
    if (position < input.length()) {
        if (currentChar == '\n') {
            line++;
            column = 1;
        } else {
            column++;
        }
        position++;
        
        if (position < input.length()) {
            currentChar = input[position];
        } else {
            currentChar = '\0';
        }
    }
}

char CustomLexer::peek(int offset) const {
    size_t peekPos = position + offset;
    if (peekPos < input.length()) {
        return input[peekPos];
    }
    return '\0';
}

void CustomLexer::skipWhitespaceAndNewlines() {
    while (currentChar != '\0' && std::isspace(currentChar)) {
        advance();
    }
}

CustomToken CustomLexer::processNumber() {
    int startColumn = column;
    std::string result;
    
    // Process regular decimal number
    while (currentChar != '\0' && std::isdigit(currentChar)) {
        result += currentChar;
        advance();
    }
    
    // Check for floating point
    if (currentChar == '.' && std::isdigit(peek())) {
        return processFloatingPoint(result);
    }
    
    // Convert to numeric value
    double value = std::stod(result);
    return CustomToken(CustomTokenType::NUMBER, result, line, startColumn, value);
}

CustomToken CustomLexer::processFloatingPoint(const std::string& integerPart) {
    int startColumn = column - integerPart.length();
    std::string result = integerPart + ".";
    advance(); // skip '.'
    
    while (currentChar != '\0' && std::isdigit(currentChar)) {
        result += currentChar;
        advance();
    }
    
    double value = std::stod(result);
    return CustomToken(CustomTokenType::NUMBER, result, line, startColumn, value);
}

CustomToken CustomLexer::processIdentifier() {
    int startColumn = column;
    std::string result;
    
    // First character must be letter or underscore
    if (isValidIdentifierStart(currentChar)) {
        result += currentChar;
        advance();
        
        // Rest can be letters, digits, or underscore
        while (currentChar != '\0' && isValidIdentifierChar(currentChar)) {
            result += currentChar;
            advance();
        }
        
        // Check if it's a keyword
        auto it = keywords.find(result);
        if (it != keywords.end()) {
            return CustomToken(it->second, result, line, startColumn);
        } else {
            return CustomToken(CustomTokenType::ID, result, line, startColumn);
        }
    }
    
    return createErrorToken("Invalid identifier");
}

CustomToken CustomLexer::processString() {
    int startColumn = column;
    std::string result;
    
    advance(); // Skip opening quote
    
    while (currentChar != '\0' && currentChar != '"') {
        if (currentChar == '\\' && peek() != '\0') {
            advance(); // Skip backslash
            switch (currentChar) {
                case 'n': result += '\n'; break;
                case 't': result += '\t'; break;
                case 'r': result += '\r'; break;
                case 'b': result += '\b'; break;
                case 'f': result += '\f'; break;
                case 'v': result += '\v'; break;
                case '0': result += '\0'; break;
                case '\\': result += '\\'; break;
                case '"': result += '"'; break;
                default: result += currentChar; break;
            }
        } else {
            result += currentChar;
        }
        advance();
    }
    
    if (currentChar == '"') {
        advance(); // Skip closing quote
        return CustomToken(CustomTokenType::STRING, result, line, startColumn);
    } else {
        return createErrorToken("Unterminated string literal");
    }
}

CustomToken CustomLexer::processOperator() {
    int startColumn = column;
    std::string opSequence = getOperatorSequence();
    
    auto it = operators.find(opSequence);
    if (it != operators.end()) {
        // Advance past the operator
        for (size_t i = 0; i < opSequence.length(); i++) {
            advance();
        }
        return CustomToken(it->second, opSequence, line, startColumn);
    }
    
    return createErrorToken("Unknown operator: " + opSequence);
}

bool CustomLexer::isValidIdentifierStart(char c) const {
    return std::isalpha(c) || c == '_';
}

bool CustomLexer::isValidIdentifierChar(char c) const {
    return std::isalnum(c) || c == '_';
}

bool CustomLexer::isOperatorStart(char c) const {
    return singleCharOperators.find(c) != singleCharOperators.end();
}

std::string CustomLexer::getOperatorSequence() {
    // Try multi-character operators first (maximal munch)
    if (position + 1 < input.length()) {
        std::string twoChar = std::string(1, currentChar) + std::string(1, peek());
        if (operators.find(twoChar) != operators.end()) {
            return twoChar;
        }
    }
    
    // Single character operator
    return std::string(1, currentChar);
}

CustomToken CustomLexer::getNextToken() {
    // Skip whitespace
    skipWhitespaceAndNewlines();
    
    // Check for end of file
    if (currentChar == '\0') {
        return CustomToken(CustomTokenType::END_OF_FILE, "", line, column);
    }
    
    int startColumn = column;
    
    // Numbers
    if (std::isdigit(currentChar)) {
        return processNumber();
    }
    
    // Identifiers and keywords
    if (isValidIdentifierStart(currentChar)) {
        return processIdentifier();
    }
    
    // Strings
    if (currentChar == '"') {
        return processString();
    }
    
    // Operators
    if (isOperatorStart(currentChar)) {
        return processOperator();
    }
    
    // Delimiters
    if (delimiters.find(currentChar) != delimiters.end()) {
        char delimiter = currentChar;
        advance();
        
        CustomTokenType type;
        switch (delimiter) {
            case '(': type = CustomTokenType::LPAREN; break;
            case ')': type = CustomTokenType::RPAREN; break;
            case '{': type = CustomTokenType::LBRACE; break;
            case '}': type = CustomTokenType::RBRACE; break;
            case '[': type = CustomTokenType::LBRACKET; break;
            case ']': type = CustomTokenType::RBRACKET; break;
            case ',': type = CustomTokenType::COMMA; break;
            case ';': type = CustomTokenType::SEMICOLON; break;
            case '|': type = CustomTokenType::PIPE; break;
            default: type = CustomTokenType::ERROR; break;
        }
        
        return CustomToken(type, std::string(1, delimiter), line, startColumn);
    }
    
    // Unknown character
    std::string errorChar(1, currentChar);
    advance();
    return createErrorToken("Unrecognized character: " + errorChar);
}

void CustomLexer::addError(const std::string& message) {
    errors.push_back("Lexer Error at line " + std::to_string(line) + ", column " + std::to_string(column) + ": " + message);
}

CustomToken CustomLexer::createErrorToken(const std::string& message) {
    addError(message);
    return CustomToken(CustomTokenType::ERROR, message, line, column);
}

void CustomLexer::setInput(const std::string& source) {
    input = source;
    reset();
}

void CustomLexer::reset() {
    position = 0;
    line = 1;
    column = 1;
    errors.clear();
    
    if (!input.empty()) {
        currentChar = input[0];
    } else {
        currentChar = '\0';
    }
}

int CustomLexer::yylex() {
    currentToken = getNextToken();
    
    // Update global variables for Bison compatibility
    yylineno = currentToken.line;
    yycolumn = currentToken.column;
    
    // Free previous yytext if it was allocated
    if (yytext) {
        free(yytext);
        yytext = nullptr;
    }
    
    // Allocate new yytext
    yytext = strdup(currentToken.lexeme.c_str());
    
    // Set yylval based on token type
    if (currentToken.type == CustomTokenType::NUMBER) {
        yylval_dval = currentToken.numericValue;
    } else if (currentToken.type == CustomTokenType::ID || currentToken.type == CustomTokenType::STRING) {
        if (yylval_sval) {
            free(yylval_sval);
        }
        yylval_sval = strdup(currentToken.lexeme.c_str());
    }
    
    // Print token for debugging (like original lexer)
    std::cout << currentToken.toString() << std::endl;
    
    return currentToken.toBisonToken();
}

std::vector<CustomToken> CustomLexer::tokenize() {
    std::vector<CustomToken> tokens;
    CustomToken token = getNextToken();
    
    while (token.type != CustomTokenType::END_OF_FILE) {
        tokens.push_back(token);
        token = getNextToken();
    }
    
    tokens.push_back(token); // Add EOF token
    return tokens;
}

void CustomLexer::printTokens(const std::vector<CustomToken>& tokens) const {
    for (const auto& token : tokens) {
        std::cout << token.toString() << " (Line: " << token.line << ", Column: " << token.column << ")" << std::endl;
    }
}

// Bison interface functions
extern "C" {
    int yylex() {
        if (globalLexer) {
            return globalLexer->yylex();
        }
        return 0; // EOF
    }
    
    void yyerror(const char* s) {
        std::cerr << "Parse error at line " << yylineno << ", column " << yycolumn 
                  << ": " << s;
        if (yytext) {
            std::cerr << " near '" << yytext << "'";
        }
        std::cerr << std::endl;
    }
}